---
title: "Project1 Group14"
format: html
editor: visual
---

*Authored by Derek Chao and Kim Costello*

## Query API Function

The Public Use Microdata Sample from the US Census Bureau contains records about demographics and housing for individuals in the US. Access to these PUMS files is located at Census.gov. In the following sections below, functions are generated to query the census API to obtain specific data related to the 2010 - 2022 survey years. 


Access is needed to the following packages to successfully run the function. 
```{r}
library(DBI)
library(dplyr)
library(jsonlite)
library(lubridate)
library(tibble)
library(httr)
library(stringr)
library(ggplot2)

```


In the code below, the census API is queried to return the code values for two specific variables, JWAP and JWDP. This is one way to be able to reference the code values later on. However, a more efficient way is provided in the function below to create a variable dictionary, that can look up code values for any specified variable. 
```{r}
URL_jwap_code <- "https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json"
jwap_code_returns <- httr::GET(URL_jwap_code)
parsed_jwap_code <- jsonlite::fromJSON(rawToChar(jwap_code_returns$content))
jwap_code <- as.list(parsed_jwap_code$values$item)

URL_jwdp_code <- "https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json"
jwdp_code_returns <- httr::GET(URL_jwdp_code)
parsed_jwdp_code <- jsonlite::fromJSON(rawToChar(jwdp_code_returns$content))
jwdp_code <- as.list(parsed_jwdp_code$values$item)

```

The following function is to query the Public Use Microdata Sample (PUMS) Census API.

Features of the function include:

-   Allows user to choose the year of survey (2022 as default).

-   Allows the user to specify the numeric variables (AGEP and PWGTP as default, with PWGTP always being returned), with restriction of at least one numeric variable specified other than PWGTP. 

-   Allows the user to specify the categorical variables (SEX as default), with restriction of at least one categorical variable specified.

-   Allows the user to specify the geography level (state, division, or region with state being the default) and the geography code (37 is the current default).

-   Checks that a valid value was given for the year (between 2010 and 2022).

-   Checks that the numeric and categorical variables specified are in the list of variables of interest.

-   Checks that a valid geography level was given.

-   Returns AGEP, GASP, GRPIP, ad JWMNP as numeric variables, JWAP and JWDP as time values, and categorical variables as factors. 

```{r}
# Write a function to query the API that allows the user to change the following items
query_census_api <- function(year = 2022, 
                             num_var = "AGEP", 
                             cat_var = "SEX", 
                             geography = "state", 
                             geo_code = "37") {
  
  NUM_ALLOWED <- c("AGEP","GASP","GRPIP","JWAP","JWDP","JWMNP")
  CAT_ALLOWED <- c("FER","HHL","HISPEED","JWTRNS","SCH","SCHL","SEX")
  
# This function converts a 12-hour time to minutes after midnight.
.time_to_minutes <- function(x) {
    x <- tolower(trimws(x))
    if (x %in% c("null","n/a","na","")) return(NA_real_)
    m <- stringr::str_match(x, "^(\\d{1,2}):(\\d{2})\\s*([ap])\\.m\\.$")
    if (is.na(m[1,1])) return(NA_real_)
    hh <- as.numeric(m[1,2]); mm <- as.numeric(m[1,3]); ap <- m[1,4]
    if (ap == "a" && hh == 12) hh <- 0
    if (ap == "p" && hh != 12) hh <- hh + 12
    hh*60 + mm
}
  
  # THis function labels a single time or range to midpoint minutes
  label_time_midpoint_minutes <- function(lbl) {
    if (is.na(lbl)) return(NA_real_)
    s <- tolower(trimws(lbl))
    if (startsWith(s, "n/a") || s == "null") return(NA_real_)
    rng <- stringr::str_match(s, "^(.+?)\\s+to\\s+(.+)$")
    if (!is.na(rng[1,1])) {
      t1 <- .time_to_minutes(trimws(rng[1,2]))
      t2 <- .time_to_minutes(trimws(rng[1,3]))
      return(mean(c(t1, t2), na.rm = TRUE))
    }
    .time_to_minutes(s)
  }
  
# This function Formats minutes-after-midnight as a 12-hour time label.
minutes_to_ampm <- function(m) {
  if (is.na(m)) return(NA_character_)
  m_round <- as.integer(round(m))      # ensure whole minutes
  h       <- (m_round %/% 60) %% 24    # 0–23
  mm      <- m_round %% 60             # 0–59 (integer)

  ap  <- if (h >= 12) "p.m." else "a.m."
  h12 <- h %% 12
  if (h12 == 0) h12 <- 12

  sprintf("%d:%02d %s", h12, mm, ap)
}

  # get code/label dictionary for a var
  get_var_dictionary <- function(year, var) {
    url <- sprintf("https://api.census.gov/data/%d/acs/acs1/pums/variables/%s.json", year, var)
    resp <- httr::GET(url)
    if (httr::http_error(resp)) stop("Failed to fetch dictionary for: ", var)
    js <- jsonlite::fromJSON(rawToChar(resp$content), simplifyVector = FALSE)
    vals <- js$values
    if (is.null(vals)) return(data.frame(code=character(), label=character()))
    if (!is.null(vals$index) && !is.null(vals$item)) {
      codes  <- as.character(unlist(vals$index, use.names = FALSE))
      labels <- as.character(unlist(vals$item,  use.names = FALSE))
      if (length(codes) != length(labels)) {
        nm <- names(vals$item)
        if (!is.null(nm) && length(nm) == length(labels)) codes <- nm else
          return(data.frame(code=character(), label=character()))
      }
      return(data.frame(code=codes, label=labels, check.names = FALSE))
    }
    if (!is.null(vals$item)) {
      labels <- as.character(unlist(vals$item, use.names = TRUE))
      codes  <- names(vals$item); if (is.null(codes)) codes <- as.character(seq_along(labels))
      return(data.frame(code=codes, label=labels, check.names = FALSE))
    }
    data.frame(code=character(), label=character())
  }

  # This functions keeps null characters as null and changes non null characters to 3 characters
  normalize_code <- function(x) {
  x_chr     <- trimws(as.character(x))
  is_missing <- is.na(x) | x_chr == ""
  is_null    <- toupper(x_chr) == "NULL"

  out <- x_chr
  out[!(is_missing | is_null)] <- stringr::str_pad(out[!(is_missing | is_null)], width = 3, pad = "0")
  out[is_null]    <- "NULL"
  out[is_missing] <- NA_character_
  out
  }
  
  # This function returns TRUE if the lowercased input contains the substrings "a.m." or "p.m."
  is_label_string <- function(x) grepl("(a\\.m\\.|p\\.m\\.)", tolower(x))
  
  # Validations
  if (year < 2010 | year > 2022) stop("Invalid Year")
  
  if (!all(num_var %in% NUM_ALLOWED)) stop("Invalid Numeric Variable")
  
  if (!all(cat_var %in% CAT_ALLOWED)) stop("Invalid Categorical Variable")
  
  if (!(tolower(geography) %in% c("all","state","division","region"))) {
    stop("Invalid Geography Level")
  }
  
  if (length(setdiff(num_var, "PWGTP")) < 1L) {
    stop("You must request at least one numeric variable other than PWGTP.")
  }
  if (length(cat_var) < 1L) {
    stop("You must request at least one categorical variable.")
  }
  
# Build URL
  get_vars   <- unique(c("PWGTP", num_var, cat_var))
  get_clause <- paste(get_vars, collapse = ",")
  
  geography <- tolower(geography)
  for_clause <- switch(
    geography,
    "all"      = "",
    "state"    = paste0("&for=state:", geo_code),
    "division" = paste0("&for=division:", geo_code),
    "region"   = paste0("&for=region:", geo_code)
  )
  geo_col <- switch(
    geography,
    "all" = NULL, "state" = "state", "division" = "division", "region" = "region"
  )
  
  url_census <- paste0("https://api.census.gov/data/", year,
                       "/acs/acs1/pums?get=", get_clause, for_clause)
  
  #  Request and parse
  census_stats   <- httr::GET(url_census)
  if (httr::http_error(census_stats)) stop("API request failed: ", url_census)
  
  parsed_census  <- jsonlite::fromJSON(rawToChar(census_stats$content))
  census_data    <- tibble::as_tibble(parsed_census)
  census_data    <- `colnames<-`(census_data, census_data[1,])
  census_data    <- census_data[-1,]
  
  # Coercions
  if ("PWGTP" %in% names(census_data)) {
    census_data$PWGTP <- suppressWarnings(as.numeric(census_data$PWGTP))
  }
  simple_numeric <- setdiff(intersect(num_var, names(census_data)), c("JWAP","JWDP"))
  for (v in simple_numeric) {
    census_data[[v]] <- suppressWarnings(as.numeric(census_data[[v]]))
  }
  
  normalize_code <- function(x) {
    x <- trimws(as.character(x))
    is_null <- toupper(x) == "NULL"
    x[!is_null] <- stringr::str_pad(x[!is_null], width = 3, pad = "0")  # "1" -> "001"
    x[is_null] <- "NULL"
    x
  }
  
  if ("JWAP" %in% names(census_data)) {
    raw <- as.character(census_data$JWAP)
    if (any(is_label_string(raw))) {
      mins <- vapply(raw, label_time_midpoint_minutes, numeric(1))
    } else {
      dict <- get_var_dictionary(year, "JWAP")
      if (nrow(dict) > 0) {
        lab_map <- stats::setNames(dict$label, dict$code)
        labs    <- unname(lab_map[ normalize_code(raw) ])
        mins    <- vapply(labs, label_time_midpoint_minutes, numeric(1))
      } else {
        mins <- rep(NA_real_, length(raw))
      }
    }
    census_data$JWAP_min <- mins
    census_data$JWAP     <- vapply(mins, minutes_to_ampm, character(1))
  }

  if ("JWDP" %in% names(census_data)) {
    raw <- as.character(census_data$JWDP)
    if (any(is_label_string(raw))) {
      mins <- vapply(raw, label_time_midpoint_minutes, numeric(1))
    } else {
      dict <- get_var_dictionary(year, "JWDP")
      if (nrow(dict) > 0) {
        lab_map <- stats::setNames(dict$label, dict$code)
        labs    <- unname(lab_map[ normalize_code(raw) ])
        mins    <- vapply(labs, label_time_midpoint_minutes, numeric(1))
      } else {
        mins <- rep(NA_real_, length(raw))
      }
    }
    census_data$JWDP_min <- mins
    census_data$JWDP     <- vapply(mins, minutes_to_ampm, character(1))
  }
  
  # categoricals -> factors 
  for (v in intersect(cat_var, names(census_data))) {
    census_data[[v]] <- factor(census_data[[v]])
  }
  
  census_data |>
    select(PWGTP, num_var, cat_var, geography)
  
  # Adding class of 'census'
  class(census_data) <- c("census", class(census_data))
  census_data
}
```

This is a test for the `query_census_api` function.

```{r}
query_census_api(num_var = c("AGEP", "GASP", "JWAP", "JWDP", "JWMNP"))


```

The following function is to use the `query_census_api` function to query the Census API for multiple survey years.

```{r}
query_multiyear_census <- function(census_years, 
                                   num_var = "AGEP",
                                   cat_var = "SEX", 
                                   geography = "state",
                                   geo_code = "37") {
  combined_data <- tibble()
  for (i in seq_along(census_years)){
    df_i <- query_census_api(year = census_years[i], num_var, cat_var, geography, geo_code)
    df_i$survey_year <- census_years[[i]]
    combined_data <- rbind(combined_data, df_i)
  }

# Adding class of 'census'
  class(combined_data) <- c("census", class(combined_data))
  combined_data
}

```

The following is to test the `query_multiyear_census` function. 

```{r}
# Test function and create tibble for use in testing the summarizing function
df1 <- query_multiyear_census(census_years = c("2019", "2022"), num_var = c("AGEP", "GASP","GRPIP"), cat_var = c("FER","HHL","HISPEED","JWTRNS","SCH","SCHL","SEX"))
head(df1, 10)
```


## Summarizing Function

The following function can be used to summarize the data returned from the census API. 

Features of this function include: 
-   Produces means and standard deviations for numeric variables (other than PWGTP). 
-   Produces counts for categorical variables
-   Returns values as a list

```{r}
summary.census <- function(my_tibble, num_var, cat_var){
  
 if (!"PWGTP" %in% names(my_tibble)) stop("PWGTP weight column is missing.")
  w <- suppressWarnings(as.numeric(my_tibble$PWGTP))
  
res_num <- list()
  for (v in num_var) {
    if (!v %in% names(my_tibble)) next
    # checks if x and w are present, if not present, then assigns na to mean and sd
    x  <- suppressWarnings(as.numeric(my_tibble[[v]]))
    ok <- !is.na(x) & !is.na(w)
    if (!any(ok)) {
      res_num[[v]] <- c(mean = NA_real_, sd = NA_real_) # set to na if 
    # if present then calculates the mean and sd
    } else {
      sw   <- sum(w[ok])
      m    <- sum(w[ok] * x[ok]) / sw
      ex2  <- sum(w[ok] * x[ok]^2) / sw
      sd_w <- sqrt(max(0, ex2 - m^2))
      res_num[[v]] <- c(mean = m, sd = sd_w)
    }
  }

res_cat <- list()
for (v in cat_var) {
  if (!v %in% names(my_tibble)) next
  # checks if f and w are present, if not count is 0
  f  <- as.character(my_tibble[[v]])
  ok <- !is.na(f) & !is.na(w)
  if (!any(ok)) {
    res_cat[[v]] <- numeric(0)
  } else {
    # weighted counts by level 
    counts <- tapply(w[ok], f[ok], sum, default = 0)
    counts <- counts[order(names(counts))]
    res_cat[[v]] <- as.numeric(counts)
    names(res_cat[[v]]) <- names(counts)
  }
}

  

  # return as a named list
  list(numeric = res_num, categorical = res_cat)
}
```

This is to test the `summary_census` function, using the previously saved tibble, `df1`. 

```{r}
summary.census(df1, num_var = c("AGEP", "GASP"), cat_var = c("FER","HHL","HISPEED","JWTRNS","SCH","SCHL","SEX"))
```

## Plotting Function

The following function can be used to generate a boxplot for a census class tibble, allowing the user to select the desired numeric variable and categorical variable.
NOTE: This function accounts for the weights (PWGTP) when generating the plots. 

```{r}
# function for plotting
plot_census <- function(df, num_var, cat_var) {
  library(ggplot2)
  ggplot(df, aes_string(x = cat_var, y = num_var, weight = "PWGTP")) +
    geom_boxplot() +
    labs(x = cat_var, y = num_var) +
    theme_minimal()
}
```

This is to test the `plot_census` function. 

```{r}
data <- query_census_api(num_var = c("AGEP","GASP","JWAP","JWDP","JWMNP"))
plot_census(data, "AGEP", "SEX")

```


## Investigating the Data

We are interested in investigating the difference in age and those who gave birth to a child within the past 12 months during the 2010 and 2022 census years in North Carolina (state code 37).

Since we want to plot the years separately, the following code will query the API for each year to create two separate datasets.

```{r}
census_2010 <- query_census_api(year = 2010, num_var = "AGEP", cat_var = "FER") 
census_2022 <- query_census_api(num_var = "AGEP", cat_var = "FER")
```

Now, let's see these variables summarized by mean and standard deviation for age, and the count for those who gave birth to a child within the past 12 months.

```{r}
#For the 2010 census
summary.census(census_2010, num_var = "AGEP", cat_var = "FER")
```

```{r}
#For the 2022 census
summary.census(census_2022, num_var = "AGEP", cat_var = "FER")
```

In general, the average age in 2010 was 37.3 years old, and the average age in 2019 was slightly higher at 39.6 years old.

For the number of those who gave birth a child within 12 months, the codes are as follows:

-   0 : N/A, which means individuals were male, less than 15 years old, or greater than 50 years old.

-   1 : Did have a child in the past 12 months. 

-   2 : Did not have a child in the past 12 months.

The count for those who did have a child in the past 12 months declined in 2022, from 133,976 in 2010 to 127,864 in 2022. There are numerous factors that could contribute to the decline in births, but one could speculate that social and economic factors, specifically related to the COVID-19 pandemic, could attribute to this decline.

Now to visually see the summaries for those who gave birth in the past 12 months, as it relates to age, for each year.

```{r}
#Plot for 2010 census
plot_census(census_2010, num_var = "AGEP", cat_var = "FER")

#Plot of 2022 census
plot_census(census_2022, num_var = "AGEP", cat_var = "FER")
```

Visually, the data between years 2010 and 2022 do not appear to be significantly different. However,there is a slight increase in the average age from 2010 to 2022 in those who gave birth in the past 12 months (FER code 1). The minimum age and maximum age of those who gave birth within the past 12 months for both years appear to be approximately 15 and 50 years old, respectively, with some possible outliers around age 50 (right above the max).

Overall, the functions to query the census API, summarize the numeric and categorical variables, and plot them, provide ways to transform raw data from the PUMS Census into understanding, insight, and knowledge.
