[
  {
    "objectID": "Project1_Group14.html",
    "href": "Project1_Group14.html",
    "title": "Project1_Group14",
    "section": "",
    "text": "The following function is to query the Public Use Microdata Sample (PUMS) Census API. But first, we need to define the values for codes in the JWAP and JWDP variables.\n\nlibrary(DBI)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(jsonlite)\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\nlibrary(tibble)\nlibrary(httr)\nlibrary(stringr)\nlibrary(ggplot2)\n\n\nURL_jwap_code <- \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\"\njwap_code_returns <- httr::GET(URL_jwap_code)\nparsed_jwap_code <- jsonlite::fromJSON(rawToChar(jwap_code_returns$content))\njwap_code <- as.list(parsed_jwap_code$values$item)\n\nURL_jwdp_code <- \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json\"\njwdp_code_returns <- httr::GET(URL_jwdp_code)\nparsed_jwdp_code <- jsonlite::fromJSON(rawToChar(jwdp_code_returns$content))\njwdp_code <- as.list(parsed_jwdp_code$values$item)\n\nFeatures of the function include:\n\nAllows user to choose the year of survey (2022 as default).\nAllows the user to specify the numeric variables (AGEP and PWGTP as default, with PWGTP always being returned).\nAllows the user to specify the categorical variables (SEX as default).\nAllows the user to specify the geography level (state, division, region with state being the default) and the geography code (37 is the current default).\nChecks that a valid value was give for the year (between 2010 and 2022).\nChecks that the numeric and categorical variables specified are in the list of variables of interest.\nChecks that a valid geography level was given.\n\n\n# Write a function to query the API that allows the user to change the following items\nquery_census_api <- function(year = 2022, \n                             num_var = \"AGEP\", \n                             cat_var = \"SEX\", \n                             geography = \"state\", \n                             geo_code = \"37\") {\n  \n  NUM_ALLOWED <- c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWAP\",\"JWDP\",\"JWMNP\")\n  CAT_ALLOWED <- c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\")\n  \n# This function converts a 12-hour time to minutes after midnight.\n.time_to_minutes <- function(x) {\n    x <- tolower(trimws(x))\n    if (x %in% c(\"null\",\"n/a\",\"na\",\"\")) return(NA_real_)\n    m <- stringr::str_match(x, \"^(\\\\d{1,2}):(\\\\d{2})\\\\s*([ap])\\\\.m\\\\.$\")\n    if (is.na(m[1,1])) return(NA_real_)\n    hh <- as.numeric(m[1,2]); mm <- as.numeric(m[1,3]); ap <- m[1,4]\n    if (ap == \"a\" && hh == 12) hh <- 0\n    if (ap == \"p\" && hh != 12) hh <- hh + 12\n    hh*60 + mm\n}\n  \n  # THis function labels a single time or range to midpoint minutes\n  label_time_midpoint_minutes <- function(lbl) {\n    if (is.na(lbl)) return(NA_real_)\n    s <- tolower(trimws(lbl))\n    if (startsWith(s, \"n/a\") || s == \"null\") return(NA_real_)\n    rng <- stringr::str_match(s, \"^(.+?)\\\\s+to\\\\s+(.+)$\")\n    if (!is.na(rng[1,1])) {\n      t1 <- .time_to_minutes(trimws(rng[1,2]))\n      t2 <- .time_to_minutes(trimws(rng[1,3]))\n      return(mean(c(t1, t2), na.rm = TRUE))\n    }\n    .time_to_minutes(s)\n  }\n  \n# This function Formats minutes-after-midnight as a 12-hour time label.\nminutes_to_ampm <- function(m) {\n  if (is.na(m)) return(NA_character_)\n  m_round <- as.integer(round(m))      # ensure whole minutes\n  h       <- (m_round %/% 60) %% 24    # 0–23\n  mm      <- m_round %% 60             # 0–59 (integer)\n\n  ap  <- if (h >= 12) \"p.m.\" else \"a.m.\"\n  h12 <- h %% 12\n  if (h12 == 0) h12 <- 12\n\n  sprintf(\"%d:%02d %s\", h12, mm, ap)\n}\n\n  # get code/label dictionary for a var\n  get_var_dictionary <- function(year, var) {\n    url <- sprintf(\"https://api.census.gov/data/%d/acs/acs1/pums/variables/%s.json\", year, var)\n    resp <- httr::GET(url)\n    if (httr::http_error(resp)) stop(\"Failed to fetch dictionary for: \", var)\n    js <- jsonlite::fromJSON(rawToChar(resp$content), simplifyVector = FALSE)\n    vals <- js$values\n    if (is.null(vals)) return(data.frame(code=character(), label=character()))\n    if (!is.null(vals$index) && !is.null(vals$item)) {\n      codes  <- as.character(unlist(vals$index, use.names = FALSE))\n      labels <- as.character(unlist(vals$item,  use.names = FALSE))\n      if (length(codes) != length(labels)) {\n        nm <- names(vals$item)\n        if (!is.null(nm) && length(nm) == length(labels)) codes <- nm else\n          return(data.frame(code=character(), label=character()))\n      }\n      return(data.frame(code=codes, label=labels, check.names = FALSE))\n    }\n    if (!is.null(vals$item)) {\n      labels <- as.character(unlist(vals$item, use.names = TRUE))\n      codes  <- names(vals$item); if (is.null(codes)) codes <- as.character(seq_along(labels))\n      return(data.frame(code=codes, label=labels, check.names = FALSE))\n    }\n    data.frame(code=character(), label=character())\n  }\n\n  # This functions keeps null characters as null and changes non null characters to 3 characters\n  normalize_code <- function(x) {\n  x_chr     <- trimws(as.character(x))\n  is_missing <- is.na(x) | x_chr == \"\"\n  is_null    <- toupper(x_chr) == \"NULL\"\n\n  out <- x_chr\n  out[!(is_missing | is_null)] <- stringr::str_pad(out[!(is_missing | is_null)], width = 3, pad = \"0\")\n  out[is_null]    <- \"NULL\"\n  out[is_missing] <- NA_character_\n  out\n  }\n  \n  # This function returns TRUE if the lowercased input contains the substrings \"a.m.\" or \"p.m.\"\n  is_label_string <- function(x) grepl(\"(a\\\\.m\\\\.|p\\\\.m\\\\.)\", tolower(x))\n  \n  # Validations\n  if (year < 2010 | year > 2022) stop(\"Invalid Year\")\n  \n  if (!all(num_var %in% NUM_ALLOWED)) stop(\"Invalid Numeric Variable\")\n  \n  if (!all(cat_var %in% CAT_ALLOWED)) stop(\"Invalid Categorical Variable\")\n  \n  if (!(tolower(geography) %in% c(\"all\",\"state\",\"division\",\"region\"))) {\n    stop(\"Invalid Geography Level\")\n  }\n  \n  if (length(setdiff(num_var, \"PWGTP\")) < 1L) {\n    stop(\"You must request at least one numeric variable other than PWGTP.\")\n  }\n  if (length(cat_var) < 1L) {\n    stop(\"You must request at least one categorical variable.\")\n  }\n  \n# Build URL\n  get_vars   <- unique(c(\"PWGTP\", num_var, cat_var))\n  get_clause <- paste(get_vars, collapse = \",\")\n  \n  geography <- tolower(geography)\n  for_clause <- switch(\n    geography,\n    \"all\"      = \"\",\n    \"state\"    = paste0(\"&for=state:\", geo_code),\n    \"division\" = paste0(\"&for=division:\", geo_code),\n    \"region\"   = paste0(\"&for=region:\", geo_code)\n  )\n  geo_col <- switch(\n    geography,\n    \"all\" = NULL, \"state\" = \"state\", \"division\" = \"division\", \"region\" = \"region\"\n  )\n  \n  url_census <- paste0(\"https://api.census.gov/data/\", year,\n                       \"/acs/acs1/pums?get=\", get_clause, for_clause)\n  \n  #  Request and parse\n  census_stats   <- httr::GET(url_census)\n  if (httr::http_error(census_stats)) stop(\"API request failed: \", url_census)\n  \n  parsed_census  <- jsonlite::fromJSON(rawToChar(census_stats$content))\n  census_data    <- tibble::as_tibble(parsed_census)\n  census_data    <- `colnames<-`(census_data, census_data[1,])\n  census_data    <- census_data[-1,]\n  \n  # Coercions\n  if (\"PWGTP\" %in% names(census_data)) {\n    census_data$PWGTP <- suppressWarnings(as.numeric(census_data$PWGTP))\n  }\n  simple_numeric <- setdiff(intersect(num_var, names(census_data)), c(\"JWAP\",\"JWDP\"))\n  for (v in simple_numeric) {\n    census_data[[v]] <- suppressWarnings(as.numeric(census_data[[v]]))\n  }\n  \n  normalize_code <- function(x) {\n    x <- trimws(as.character(x))\n    is_null <- toupper(x) == \"NULL\"\n    x[!is_null] <- stringr::str_pad(x[!is_null], width = 3, pad = \"0\")  # \"1\" -> \"001\"\n    x[is_null] <- \"NULL\"\n    x\n  }\n  \n  if (\"JWAP\" %in% names(census_data)) {\n    raw <- as.character(census_data$JWAP)\n    if (any(is_label_string(raw))) {\n      mins <- vapply(raw, label_time_midpoint_minutes, numeric(1))\n    } else {\n      dict <- get_var_dictionary(year, \"JWAP\")\n      if (nrow(dict) > 0) {\n        lab_map <- stats::setNames(dict$label, dict$code)\n        labs    <- unname(lab_map[ normalize_code(raw) ])\n        mins    <- vapply(labs, label_time_midpoint_minutes, numeric(1))\n      } else {\n        mins <- rep(NA_real_, length(raw))\n      }\n    }\n    census_data$JWAP_min <- mins\n    census_data$JWAP     <- vapply(mins, minutes_to_ampm, character(1))\n  }\n\n  if (\"JWDP\" %in% names(census_data)) {\n    raw <- as.character(census_data$JWDP)\n    if (any(is_label_string(raw))) {\n      mins <- vapply(raw, label_time_midpoint_minutes, numeric(1))\n    } else {\n      dict <- get_var_dictionary(year, \"JWDP\")\n      if (nrow(dict) > 0) {\n        lab_map <- stats::setNames(dict$label, dict$code)\n        labs    <- unname(lab_map[ normalize_code(raw) ])\n        mins    <- vapply(labs, label_time_midpoint_minutes, numeric(1))\n      } else {\n        mins <- rep(NA_real_, length(raw))\n      }\n    }\n    census_data$JWDP_min <- mins\n    census_data$JWDP     <- vapply(mins, minutes_to_ampm, character(1))\n  }\n  \n  # categoricals -> factors \n  for (v in intersect(cat_var, names(census_data))) {\n    census_data[[v]] <- factor(census_data[[v]])\n  }\n  \n  census_data |>\n    select(PWGTP, num_var, cat_var, geography) \n}\n\nTest function.\n\nquery_census_api(num_var = c(\"AGEP\", \"GASP\", \"JWAP\", \"JWDP\", \"JWMNP\"))\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(num_var)\n\n  # Now:\n  data %>% select(all_of(num_var))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(cat_var)\n\n  # Now:\n  data %>% select(all_of(cat_var))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(geography)\n\n  # Now:\n  data %>% select(all_of(geography))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n\n\n# A tibble: 109,230 × 8\n   PWGTP  AGEP  GASP JWAP      JWDP      JWMNP SEX   state\n   <dbl> <dbl> <dbl> <chr>     <chr>     <dbl> <fct> <chr>\n 1    45    80     3 <NA>      <NA>          0 1     37   \n 2     7    60     3 <NA>      <NA>          0 1     37   \n 3    64    18     3 8:07 a.m. 8:02 a.m.     5 1     37   \n 4    56    18     3 <NA>      <NA>          0 1     37   \n 5    50    87     3 <NA>      <NA>          0 2     37   \n 6    56    18     3 <NA>      <NA>          0 1     37   \n 7    36    39     3 <NA>      <NA>          0 1     37   \n 8    38    40     3 <NA>      <NA>          0 1     37   \n 9    38    21     3 8:07 a.m. 8:02 a.m.     5 1     37   \n10     8    19     3 <NA>      <NA>          0 2     37   \n# ℹ 109,220 more rows\n\n\nThe following function is to use the query_census_api function to query the Census API for multiple survey years.\n\nquery_multiyear_census <- function(census_years, \n                                   num_var = \"AGEP\",\n                                   cat_var = \"SEX\", \n                                   geography = \"state\",\n                                   geo_code = \"37\") {\n  combined_data <- tibble()\n  for (i in seq_along(census_years)){\n    df_i <- query_census_api(year = census_years[i], num_var, cat_var, geography, geo_code)\n    df_i$survey_year <- census_years[[i]]\n    combined_data <- rbind(combined_data, df_i)\n  }\n\n# Adding class of 'census'\n  class(combined_data) <- c(\"census\", class(combined_data))\n  combined_data\n}\n\n\n# Example to create tibble for summarizing\ndf1 <- query_multiyear_census(census_years = c(\"2019\", \"2022\"), num_var = c(\"AGEP\", \"GASP\",\"GRPIP\"), cat_var = c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\"))\nhead(df1, 10)\n\n# A tibble: 10 × 13\n   PWGTP  AGEP  GASP GRPIP FER   HHL   HISPEED JWTRNS SCH   SCHL  SEX   state\n   <dbl> <dbl> <dbl> <dbl> <fct> <fct> <fct>   <fct>  <fct> <fct> <fct> <chr>\n 1    70    52     3     0 0     0     0       0      1     14    1     37   \n 2    70    50     3     0 0     0     0       0      1     16    1     37   \n 3    16    28     3     0 0     0     0       0      1     16    1     37   \n 4    80    49     3     0 0     0     0       0      1     9     1     37   \n 5     7     3     3     0 0     0     0       0      2     1     1     37   \n 6    52    30     3     0 0     0     0       0      1     19    1     37   \n 7    82    67     3     0 0     0     0       0      1     11    1     37   \n 8    31    19     3     0 0     0     0       0      3     19    1     37   \n 9    72    22     3     0 2     0     0       0      3     19    2     37   \n10    62    67     3     0 0     0     0       0      1     20    2     37   \n# ℹ 1 more variable: survey_year <chr>"
  },
  {
    "objectID": "Project1_Group14.html#summarizing-function",
    "href": "Project1_Group14.html#summarizing-function",
    "title": "Project1_Group14",
    "section": "Summarizing Function",
    "text": "Summarizing Function\n\nsummary.census <- function(my_tibble, num_var, cat_var){\n  \n if (!\"PWGTP\" %in% names(my_tibble)) stop(\"PWGTP weight column is missing.\")\n  w <- suppressWarnings(as.numeric(my_tibble$PWGTP))\n  \nres_num <- list()\n  for (v in num_var) {\n    if (!v %in% names(my_tibble)) next\n    # checks if x and w are present, if not present, then assigns na to mean and sd\n    x  <- suppressWarnings(as.numeric(my_tibble[[v]]))\n    ok <- !is.na(x) & !is.na(w)\n    if (!any(ok)) {\n      res_num[[v]] <- c(mean = NA_real_, sd = NA_real_) # set to na if \n    # if present then calculates the mean and sd\n    } else {\n      sw   <- sum(w[ok])\n      m    <- sum(w[ok] * x[ok]) / sw\n      ex2  <- sum(w[ok] * x[ok]^2) / sw\n      sd_w <- sqrt(max(0, ex2 - m^2))\n      res_num[[v]] <- c(mean = m, sd = sd_w)\n    }\n  }\n\nres_cat <- list()\nfor (v in cat_var) {\n  if (!v %in% names(my_tibble)) next\n  # checks if f and w are present, if not count is 0\n  f  <- as.character(my_tibble[[v]])\n  ok <- !is.na(f) & !is.na(w)\n  if (!any(ok)) {\n    res_cat[[v]] <- numeric(0)\n  } else {\n    # weighted counts by level \n    counts <- tapply(w[ok], f[ok], sum, default = 0)\n    counts <- counts[order(names(counts))]\n    res_cat[[v]] <- as.numeric(counts)\n    names(res_cat[[v]]) <- names(counts)\n  }\n}\n\n  \n\n  # return as a named list\n  list(numeric = res_num, categorical = res_cat)\n}\n\nTest summarizing function\n\nsummary.census(df1, num_var = c(\"AGEP\", \"GASP\"), cat_var = c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\"))\n\n$numeric\n$numeric$AGEP\n    mean       sd \n39.46438 23.17279 \n\n$numeric$GASP\n     mean        sd \n 42.44735 102.15103 \n\n\n$categorical\n$categorical$FER\n       0        1        2 \n16168595   259073  4759389 \n\n$categorical$HHL\n       0        1        2        3        4        5 \n  562135 17224295  2098141   599871   485023   217592 \n\n$categorical$HISPEED\n       0        1        2 \n 2435887 15936699  2814471 \n\n$categorical$JWTRNS\n       0        1       10       11       12        2        3        4 \n11121883  8476776   170044  1194473   103638    68951     2294     1279 \n       5        6        7        8        9 \n    8557     1324    11080    11989    14769 \n\n$categorical$SCH\n       0        1        2        3 \n  674565 15467777  4187472   857243 \n\n$categorical$SCHL\n      0       1      10      11      12      13      14      15      16      17 \n 674565  679811  318989  452026  500164  540600  569458  261588 3735439  654274 \n     18      19       2      20      21      22      23      24       3       4 \n1141595 2524732  309066 1600821 3362135 1350281  271890  222658  256390  236646 \n      5       6       7       8       9 \n 272174  283470  290205  320740  357340 \n\n$categorical$SEX\n       1        2 \n10326459 10860598"
  },
  {
    "objectID": "Project1_Group14.html#plotting-function",
    "href": "Project1_Group14.html#plotting-function",
    "title": "Project1_Group14",
    "section": "Plotting Function",
    "text": "Plotting Function\n\n# function for plotting\nplot_census <- function(df, num_var, cat_var) {\n  library(ggplot2)\n  ggplot(df, aes_string(x = cat_var, y = num_var, weight = \"PWGTP\")) +\n    geom_boxplot() +\n    labs(x = cat_var, y = num_var) +\n    theme_minimal()\n}\n\nTest Plot\n\ndata <- query_census_api(num_var = c(\"AGEP\",\"GASP\",\"JWAP\",\"JWDP\",\"JWMNP\"))\nplot_census(data, \"AGEP\", \"SEX\")\n\nWarning: `aes_string()` was deprecated in ggplot2 3.0.0.\nℹ Please use tidy evaluation idioms with `aes()`.\nℹ See also `vignette(\"ggplot2-in-packages\")` for more information."
  }
]