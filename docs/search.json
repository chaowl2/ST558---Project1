[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Project 1",
    "section": "",
    "text": "# Welcome\nThis is the homepage for our project website.\n## Open the report\n\n\n\n**Report:** [Project1_Group14.html](Project1_Group14.html)\n<div style=“margin-top:0.5rem”>\n<a class=“btn btn-primary” href=“Project1_Group14.html”>Open Project1_Group14</a>\n</div>\n## Notes\n\nThe report link points to the rendered HTML in **docs/** (created by `quarto render`).\nIf the link 404s, render again and commit/push the files in **docs/**."
  },
  {
    "objectID": "Project1_Group14.html",
    "href": "Project1_Group14.html",
    "title": "Project1 Group14",
    "section": "",
    "text": "Authored by Derek Chao and Kim Costello"
  },
  {
    "objectID": "Project1_Group14.html#query-api-function",
    "href": "Project1_Group14.html#query-api-function",
    "title": "Project1 Group14",
    "section": "Query API Function",
    "text": "Query API Function\nThe Public Use Microdata Sample from the US Census Bureau contains records about demographics and housing for individuals in the US. Access to these PUMS files is located at Census.gov. In the following sections below, functions are generated to query the census API to obtain specific data related to the 2010 - 2022 survey years, provide summaries, and generate plots.\nAccess is needed to the following packages to successfully run the functions.\n\nlibrary(DBI)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(jsonlite)\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\nlibrary(tibble)\nlibrary(httr)\nlibrary(stringr)\nlibrary(ggplot2)\n\nIn the code below, the census API is queried to return the code values for two specific variables, JWAP and JWDP. This is one way to be able to reference the code values later on. However, a more efficient way is provided in the function below to create a variable dictionary that can look up code values for any specified variable.\n\nURL_jwap_code <- \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\"\njwap_code_returns <- httr::GET(URL_jwap_code)\nparsed_jwap_code <- jsonlite::fromJSON(rawToChar(jwap_code_returns$content))\njwap_code <- as.list(parsed_jwap_code$values$item)\n\nURL_jwdp_code <- \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json\"\njwdp_code_returns <- httr::GET(URL_jwdp_code)\nparsed_jwdp_code <- jsonlite::fromJSON(rawToChar(jwdp_code_returns$content))\njwdp_code <- as.list(parsed_jwdp_code$values$item)\n\nThe following function is to query the Public Use Microdata Sample (PUMS) Census API.\nFeatures of the function include:\n\nAllows user to choose the year of survey (2022 as default).\nAllows the user to specify the numeric variables (AGEP and PWGTP as default, with PWGTP always being returned), with restriction of at least one numeric variable specified other than PWGTP.\nAllows the user to specify the categorical variables (SEX as default), with restriction of at least one categorical variable specified.\nAllows the user to specify the geography level (state, division, or region with state being the default) and the geography code (37 is the current default).\nChecks that a valid value was given for the year (between 2010 and 2022).\nChecks that the numeric and categorical variables specified are in the list of variables of interest.\nChecks that a valid geography level was given.\nReturns AGEP, GASP, GRPIP, ad JWMNP as numeric variables, JWAP and JWDP as time values, and categorical variables as factors.\n\n\n# Write a function to query the API that allows the user to change the following items\nquery_census_api <- function(year = 2022, \n                             num_var = \"AGEP\", \n                             cat_var = \"SEX\", \n                             geography = \"state\", \n                             geo_code = \"37\") {\n  \n  NUM_ALLOWED <- c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWAP\",\"JWDP\",\"JWMNP\")\n  CAT_ALLOWED <- c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\")\n  \n# This function converts a 12-hour time to minutes after midnight.\n.time_to_minutes <- function(x) {\n    x <- tolower(trimws(x))\n    if (x %in% c(\"null\",\"n/a\",\"na\",\"\")) return(NA_real_)\n    m <- stringr::str_match(x, \"^(\\\\d{1,2}):(\\\\d{2})\\\\s*([ap])\\\\.m\\\\.$\")\n    if (is.na(m[1,1])) return(NA_real_)\n    hh <- as.numeric(m[1,2]); mm <- as.numeric(m[1,3]); ap <- m[1,4]\n    if (ap == \"a\" && hh == 12) hh <- 0\n    if (ap == \"p\" && hh != 12) hh <- hh + 12\n    hh*60 + mm\n}\n  \n  # THis function labels a single time or range to midpoint minutes\n  label_time_midpoint_minutes <- function(lbl) {\n    if (is.na(lbl)) return(NA_real_)\n    s <- tolower(trimws(lbl))\n    if (startsWith(s, \"n/a\") || s == \"null\") return(NA_real_)\n    rng <- stringr::str_match(s, \"^(.+?)\\\\s+to\\\\s+(.+)$\")\n    if (!is.na(rng[1,1])) {\n      t1 <- .time_to_minutes(trimws(rng[1,2]))\n      t2 <- .time_to_minutes(trimws(rng[1,3]))\n      return(mean(c(t1, t2), na.rm = TRUE))\n    }\n    .time_to_minutes(s)\n  }\n  \n# This function Formats minutes-after-midnight as a 12-hour time label.\nminutes_to_ampm <- function(m) {\n  if (is.na(m)) return(NA_character_)\n  m_round <- as.integer(round(m))      # ensure whole minutes\n  h       <- (m_round %/% 60) %% 24    # 0–23\n  mm      <- m_round %% 60             # 0–59 (integer)\n\n  ap  <- if (h >= 12) \"p.m.\" else \"a.m.\"\n  h12 <- h %% 12\n  if (h12 == 0) h12 <- 12\n\n  sprintf(\"%d:%02d %s\", h12, mm, ap)\n}\n\n  # get code/label dictionary for a var\n  get_var_dictionary <- function(year, var) {\n    url <- sprintf(\"https://api.census.gov/data/%d/acs/acs1/pums/variables/%s.json\", year, var)\n    resp <- httr::GET(url)\n    if (httr::http_error(resp)) stop(\"Failed to fetch dictionary for: \", var)\n    js <- jsonlite::fromJSON(rawToChar(resp$content), simplifyVector = FALSE)\n    vals <- js$values\n    if (is.null(vals)) return(data.frame(code=character(), label=character()))\n    if (!is.null(vals$index) && !is.null(vals$item)) {\n      codes  <- as.character(unlist(vals$index, use.names = FALSE))\n      labels <- as.character(unlist(vals$item,  use.names = FALSE))\n      if (length(codes) != length(labels)) {\n        nm <- names(vals$item)\n        if (!is.null(nm) && length(nm) == length(labels)) codes <- nm else\n          return(data.frame(code=character(), label=character()))\n      }\n      return(data.frame(code=codes, label=labels, check.names = FALSE))\n    }\n    if (!is.null(vals$item)) {\n      labels <- as.character(unlist(vals$item, use.names = TRUE))\n      codes  <- names(vals$item); if (is.null(codes)) codes <- as.character(seq_along(labels))\n      return(data.frame(code=codes, label=labels, check.names = FALSE))\n    }\n    data.frame(code=character(), label=character())\n  }\n\n  # This functions keeps null characters as null and changes non null characters to 3 characters\n  normalize_code <- function(x) {\n  x_chr     <- trimws(as.character(x))\n  is_missing <- is.na(x) | x_chr == \"\"\n  is_null    <- toupper(x_chr) == \"NULL\"\n\n  out <- x_chr\n  out[!(is_missing | is_null)] <- stringr::str_pad(out[!(is_missing | is_null)], width = 3, pad = \"0\")\n  out[is_null]    <- \"NULL\"\n  out[is_missing] <- NA_character_\n  out\n  }\n  \n  # This function returns TRUE if the lowercased input contains the substrings \"a.m.\" or \"p.m.\"\n  is_label_string <- function(x) grepl(\"(a\\\\.m\\\\.|p\\\\.m\\\\.)\", tolower(x))\n  \n  # Validations\n  if (year < 2010 | year > 2022) stop(\"Invalid Year\")\n  \n  if (!all(num_var %in% NUM_ALLOWED)) stop(\"Invalid Numeric Variable\")\n  \n  if (!all(cat_var %in% CAT_ALLOWED)) stop(\"Invalid Categorical Variable\")\n  \n  if (!(tolower(geography) %in% c(\"all\",\"state\",\"division\",\"region\"))) {\n    stop(\"Invalid Geography Level\")\n  }\n  \n  if (length(setdiff(num_var, \"PWGTP\")) < 1L) {\n    stop(\"You must request at least one numeric variable other than PWGTP.\")\n  }\n  if (length(cat_var) < 1L) {\n    stop(\"You must request at least one categorical variable.\")\n  }\n  \n# Build URL\n  get_vars   <- unique(c(\"PWGTP\", num_var, cat_var))\n  get_clause <- paste(get_vars, collapse = \",\")\n  \n  geography <- tolower(geography)\n  for_clause <- switch(\n    geography,\n    \"all\"      = \"\",\n    \"state\"    = paste0(\"&for=state:\", geo_code),\n    \"division\" = paste0(\"&for=division:\", geo_code),\n    \"region\"   = paste0(\"&for=region:\", geo_code)\n  )\n  geo_col <- switch(\n    geography,\n    \"all\" = NULL, \"state\" = \"state\", \"division\" = \"division\", \"region\" = \"region\"\n  )\n  \n  url_census <- paste0(\"https://api.census.gov/data/\", year,\n                       \"/acs/acs1/pums?get=\", get_clause, for_clause)\n  \n  #  Request and parse\n  census_stats   <- httr::GET(url_census)\n  if (httr::http_error(census_stats)) stop(\"API request failed: \", url_census)\n  \n  parsed_census  <- jsonlite::fromJSON(rawToChar(census_stats$content))\n  census_data    <- tibble::as_tibble(parsed_census)\n  census_data    <- `colnames<-`(census_data, census_data[1,])\n  census_data    <- census_data[-1,]\n  \n  # Coercions\n  if (\"PWGTP\" %in% names(census_data)) {\n    census_data$PWGTP <- suppressWarnings(as.numeric(census_data$PWGTP))\n  }\n  simple_numeric <- setdiff(intersect(num_var, names(census_data)), c(\"JWAP\",\"JWDP\"))\n  for (v in simple_numeric) {\n    census_data[[v]] <- suppressWarnings(as.numeric(census_data[[v]]))\n  }\n  \n  normalize_code <- function(x) {\n    x <- trimws(as.character(x))\n    is_null <- toupper(x) == \"NULL\"\n    x[!is_null] <- stringr::str_pad(x[!is_null], width = 3, pad = \"0\")  # \"1\" -> \"001\"\n    x[is_null] <- \"NULL\"\n    x\n  }\n  \n  if (\"JWAP\" %in% names(census_data)) {\n    raw <- as.character(census_data$JWAP)\n    if (any(is_label_string(raw))) {\n      mins <- vapply(raw, label_time_midpoint_minutes, numeric(1))\n    } else {\n      dict <- get_var_dictionary(year, \"JWAP\")\n      if (nrow(dict) > 0) {\n        lab_map <- stats::setNames(dict$label, dict$code)\n        labs    <- unname(lab_map[ normalize_code(raw) ])\n        mins    <- vapply(labs, label_time_midpoint_minutes, numeric(1))\n      } else {\n        mins <- rep(NA_real_, length(raw))\n      }\n    }\n    census_data$JWAP_min <- mins\n    census_data$JWAP     <- vapply(mins, minutes_to_ampm, character(1))\n  }\n\n  if (\"JWDP\" %in% names(census_data)) {\n    raw <- as.character(census_data$JWDP)\n    if (any(is_label_string(raw))) {\n      mins <- vapply(raw, label_time_midpoint_minutes, numeric(1))\n    } else {\n      dict <- get_var_dictionary(year, \"JWDP\")\n      if (nrow(dict) > 0) {\n        lab_map <- stats::setNames(dict$label, dict$code)\n        labs    <- unname(lab_map[ normalize_code(raw) ])\n        mins    <- vapply(labs, label_time_midpoint_minutes, numeric(1))\n      } else {\n        mins <- rep(NA_real_, length(raw))\n      }\n    }\n    census_data$JWDP_min <- mins\n    census_data$JWDP     <- vapply(mins, minutes_to_ampm, character(1))\n  }\n  \n  # categoricals -> factors \n  for (v in intersect(cat_var, names(census_data))) {\n    census_data[[v]] <- factor(census_data[[v]])\n  }\n  \n  census_data |>\n    select(PWGTP, num_var, cat_var, geography)\n  \n  # Adding class of 'census'\n  class(census_data) <- c(\"census\", class(census_data))\n  census_data\n}\n\nThis is a test for the query_census_api function.\n\nquery_census_api(num_var = c(\"AGEP\", \"GASP\", \"JWAP\", \"JWDP\", \"JWMNP\"))\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(num_var)\n\n  # Now:\n  data %>% select(all_of(num_var))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(cat_var)\n\n  # Now:\n  data %>% select(all_of(cat_var))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(geography)\n\n  # Now:\n  data %>% select(all_of(geography))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n\n\n# A tibble: 109,230 × 10\n   PWGTP  AGEP  GASP JWAP      JWDP      JWMNP SEX   state JWAP_min JWDP_min\n   <dbl> <dbl> <dbl> <chr>     <chr>     <dbl> <fct> <chr>    <dbl>    <dbl>\n 1    45    80     3 <NA>      <NA>          0 1     37          NA       NA\n 2     7    60     3 <NA>      <NA>          0 1     37          NA       NA\n 3    64    18     3 8:07 a.m. 8:02 a.m.     5 1     37         487      482\n 4    56    18     3 <NA>      <NA>          0 1     37          NA       NA\n 5    50    87     3 <NA>      <NA>          0 2     37          NA       NA\n 6    56    18     3 <NA>      <NA>          0 1     37          NA       NA\n 7    36    39     3 <NA>      <NA>          0 1     37          NA       NA\n 8    38    40     3 <NA>      <NA>          0 1     37          NA       NA\n 9    38    21     3 8:07 a.m. 8:02 a.m.     5 1     37         487      482\n10     8    19     3 <NA>      <NA>          0 2     37          NA       NA\n# ℹ 109,220 more rows\n\n\nThe following function is to use the query_census_api function to query the Census API for multiple survey years.\n\nquery_multiyear_census <- function(census_years, \n                                   num_var = \"AGEP\",\n                                   cat_var = \"SEX\", \n                                   geography = \"state\",\n                                   geo_code = \"37\") {\n  combined_data <- tibble()\n  for (i in seq_along(census_years)){\n    df_i <- query_census_api(year = census_years[i], num_var, cat_var, geography, geo_code)\n    df_i$survey_year <- census_years[[i]]\n    combined_data <- rbind(combined_data, df_i)\n  }\n\n# Adding class of 'census'\n  class(combined_data) <- c(\"census\", class(combined_data))\n  combined_data\n}\n\nThe following is to test the query_multiyear_census function.\n\n# Test function and create tibble for use in testing the summarizing function\ndf1 <- query_multiyear_census(census_years = c(\"2019\", \"2022\"), num_var = c(\"AGEP\", \"GASP\",\"GRPIP\"), cat_var = c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\"))\nhead(df1, 10)\n\n# A tibble: 10 × 13\n   PWGTP  AGEP  GASP GRPIP FER   HHL   HISPEED JWTRNS SCH   SCHL  SEX   state\n   <dbl> <dbl> <dbl> <dbl> <fct> <fct> <fct>   <fct>  <fct> <fct> <fct> <chr>\n 1    70    52     3     0 0     0     0       0      1     14    1     37   \n 2    70    50     3     0 0     0     0       0      1     16    1     37   \n 3    16    28     3     0 0     0     0       0      1     16    1     37   \n 4    80    49     3     0 0     0     0       0      1     9     1     37   \n 5     7     3     3     0 0     0     0       0      2     1     1     37   \n 6    52    30     3     0 0     0     0       0      1     19    1     37   \n 7    82    67     3     0 0     0     0       0      1     11    1     37   \n 8    31    19     3     0 0     0     0       0      3     19    1     37   \n 9    72    22     3     0 2     0     0       0      3     19    2     37   \n10    62    67     3     0 0     0     0       0      1     20    2     37   \n# ℹ 1 more variable: survey_year <chr>"
  },
  {
    "objectID": "Project1_Group14.html#summarizing-function",
    "href": "Project1_Group14.html#summarizing-function",
    "title": "Project1 Group14",
    "section": "Summarizing Function",
    "text": "Summarizing Function\nThe following function can be used to summarize the data returned from the census API.\nFeatures of this function include:\n\nProduces means and standard deviations for numeric variables (other than PWGTP).\nProduces counts for categorical variables\nReturns values as a list\n\n\nsummary.census <- function(my_tibble, num_var, cat_var){\n  \n if (!\"PWGTP\" %in% names(my_tibble)) stop(\"PWGTP weight column is missing.\")\n  w <- suppressWarnings(as.numeric(my_tibble$PWGTP))\n  \nres_num <- list()\n  for (v in num_var) {\n    if (!v %in% names(my_tibble)) next\n    # checks if x and w are present, if not present, then assigns na to mean and sd\n    x  <- suppressWarnings(as.numeric(my_tibble[[v]]))\n    ok <- !is.na(x) & !is.na(w)\n    if (!any(ok)) {\n      res_num[[v]] <- c(mean = NA_real_, sd = NA_real_) # set to na if \n    # if present then calculates the mean and sd\n    } else {\n      sw   <- sum(w[ok])\n      m    <- sum(w[ok] * x[ok]) / sw\n      ex2  <- sum(w[ok] * x[ok]^2) / sw\n      sd_w <- sqrt(max(0, ex2 - m^2))\n      res_num[[v]] <- c(mean = m, sd = sd_w)\n    }\n  }\n\nres_cat <- list()\nfor (v in cat_var) {\n  if (!v %in% names(my_tibble)) next\n  # checks if f and w are present, if not count is 0\n  f  <- as.character(my_tibble[[v]])\n  ok <- !is.na(f) & !is.na(w)\n  if (!any(ok)) {\n    res_cat[[v]] <- numeric(0)\n  } else {\n    # weighted counts by level \n    counts <- tapply(w[ok], f[ok], sum, default = 0)\n    counts <- counts[order(names(counts))]\n    res_cat[[v]] <- as.numeric(counts)\n    names(res_cat[[v]]) <- names(counts)\n  }\n}\n\n  \n\n  # return as a named list\n  list(numeric = res_num, categorical = res_cat)\n}\n\nThis is to test the summary_census function, using the previously saved tibble, df1.\n\nsummary.census(df1, num_var = c(\"AGEP\", \"GASP\"), cat_var = c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\"))\n\n$numeric\n$numeric$AGEP\n    mean       sd \n39.46438 23.17279 \n\n$numeric$GASP\n     mean        sd \n 42.44735 102.15103 \n\n\n$categorical\n$categorical$FER\n       0        1        2 \n16168595   259073  4759389 \n\n$categorical$HHL\n       0        1        2        3        4        5 \n  562135 17224295  2098141   599871   485023   217592 \n\n$categorical$HISPEED\n       0        1        2 \n 2435887 15936699  2814471 \n\n$categorical$JWTRNS\n       0        1       10       11       12        2        3        4 \n11121883  8476776   170044  1194473   103638    68951     2294     1279 \n       5        6        7        8        9 \n    8557     1324    11080    11989    14769 \n\n$categorical$SCH\n       0        1        2        3 \n  674565 15467777  4187472   857243 \n\n$categorical$SCHL\n      0       1      10      11      12      13      14      15      16      17 \n 674565  679811  318989  452026  500164  540600  569458  261588 3735439  654274 \n     18      19       2      20      21      22      23      24       3       4 \n1141595 2524732  309066 1600821 3362135 1350281  271890  222658  256390  236646 \n      5       6       7       8       9 \n 272174  283470  290205  320740  357340 \n\n$categorical$SEX\n       1        2 \n10326459 10860598"
  },
  {
    "objectID": "Project1_Group14.html#plotting-function",
    "href": "Project1_Group14.html#plotting-function",
    "title": "Project1 Group14",
    "section": "Plotting Function",
    "text": "Plotting Function\nThe following function can be used to generate a boxplot for a census class tibble, allowing the user to select the desired numeric variable and categorical variable.\nNOTE: This function accounts for the weights (PWGTP) when generating the plots.\n\n# function for plotting\nplot_census <- function(df, num_var, cat_var) {\n  library(ggplot2)\n  ggplot(df, aes_string(x = cat_var, y = num_var, weight = \"PWGTP\")) +\n    geom_boxplot() +\n    labs(x = cat_var, y = num_var) +\n    theme_minimal()\n}\n\nThis is to test the plot_census function.\n\ndata <- query_census_api(num_var = c(\"AGEP\",\"GASP\",\"JWAP\",\"JWDP\",\"JWMNP\"))\nplot_census(data, \"AGEP\", \"SEX\")\n\nWarning: `aes_string()` was deprecated in ggplot2 3.0.0.\nℹ Please use tidy evaluation idioms with `aes()`.\nℹ See also `vignette(\"ggplot2-in-packages\")` for more information."
  },
  {
    "objectID": "Project1_Group14.html#investigating-the-data",
    "href": "Project1_Group14.html#investigating-the-data",
    "title": "Project1 Group14",
    "section": "Investigating the Data",
    "text": "Investigating the Data\nWe are interested in investigating the difference in age and those who gave birth to a child within the past 12 months during the 2010 and 2022 census years in North Carolina (state code 37).\nSince we want to plot the years separately, the following code will query the API for each year to create two separate datasets.\n\ncensus_2010 <- query_census_api(year = 2010, num_var = \"AGEP\", cat_var = \"FER\") \ncensus_2022 <- query_census_api(num_var = \"AGEP\", cat_var = \"FER\")\n\nNow, let’s see these variables summarized by mean and standard deviation for age, and the count for those who gave birth to a child within the past 12 months.\n\n#For the 2010 census\nsummary.census(census_2010, num_var = \"AGEP\", cat_var = \"FER\")\n\n$numeric\n$numeric$AGEP\n    mean       sd \n37.26213 22.59663 \n\n\n$categorical\n$categorical$FER\n      0       1       2 \n7170542  133976 2257040 \n\n\n\n#For the 2022 census\nsummary.census(census_2022, num_var = \"AGEP\", cat_var = \"FER\")\n\n$numeric\n$numeric$AGEP\n    mean       sd \n39.63556 23.18036 \n\n\n$categorical\n$categorical$FER\n      0       1       2 \n8179426  127864 2391683 \n\n\nIn general, the average age in 2010 was 37.3 years old, and the average age in 2019 was slightly higher at 39.6 years old.\nFor the number of those who gave birth a child within 12 months, the codes are as follows:\n\n0 : N/A, which means individuals were male, less than 15 years old, or greater than 50 years old.\n1 : Did have a child in the past 12 months.\n2 : Did not have a child in the past 12 months.\n\nThe count for those who did have a child in the past 12 months declined in 2022, from 133,976 in 2010 to 127,864 in 2022. There are numerous factors that could contribute to the decline in births, but one could speculate that social and economic factors, specifically related to the COVID-19 pandemic, could attribute to this decline.\nNow to visually see the summaries for those who gave birth in the past 12 months, as it relates to age, for each year.\n\n#Plot for 2010 census\nplot_census(census_2010, num_var = \"AGEP\", cat_var = \"FER\")\n\n\n\n#Plot of 2022 census\nplot_census(census_2022, num_var = \"AGEP\", cat_var = \"FER\")\n\n\n\n\nVisually, the data between years 2010 and 2022 do not appear to be significantly different. However,there is a slight increase in the average age from 2010 to 2022 in those who gave birth in the past 12 months (FER code 1). The minimum age and maximum age of those who gave birth within the past 12 months for both years appear to be approximately 15 and 50 years old, respectively, with some possible outliers around age 50 (right above the max).\nOverall, the functions to query the census API, summarize the numeric and categorical variables, and plot them, provide ways to transform raw data from the PUMS Census into understanding, insight, and knowledge."
  }
]